One of the requirements for a consumer to be registered to the RabbitMQ server is that a message handler be declared
in the consumer class. The message handler is the mechanism by which messages are consumed.

h3. Basic Usage
In its most basic form, a message handler method takes in the body of the received message, and a @MessageContext@
object that contains the message parameters received from the RabbitMQ server, along with the consumer's channel
that the handler should send messages through.

This is the most generic form of a message handler:
{code}
package com.example

class ExampleConsumer {
    // ...

    def handleMessage(def body, MessageContext context) {
        // Do work
    }
}
{code}

h3. Typed Message Handlers
The logic surrounding the message consumer classes will by default attempt to intelligently convert the body of
the received message from a byte array to a converted type, such as a String. Before routing the message to the
consumer and handler, the plugin will run through a list of converters that will attempt to convert the message,
and if the conversion was successful, determine if an appropriate handler has been defined.

For example, consider this JSON blob:
{code}
{"foo":"bar","hi":"there"}
{code}

If the above message is received, the converter for the Map class type will convert the byte array to a Map
of the JSON data. If a valid handler for the Map type is defined, the handler will receive the converted JSON
so that the handler does not need to handle the conversion.

The following handlers would accept the converted Map:
{code}
package com.example

class ExampleConsumer {
    // ...

    def handleMessage(Map body, MessageContext context) {
        // Do work
    }

    def handleMessage(def body, MessageContext context) {
        // Since def is a generic type (Object)
    }
}
{code}

{note}
If a converter was successfully able to convert the message body, but no handler was defined to handle the
class type, other converters will get a chance to convert the message body. In the above example, if only
a handler for the String type was defined, the handler will receive the JSON blob as a String.

If no converter is able to convert the message body, the plugin will fall back to passing the handler the raw
byte array received from the RabbitMQ server.
{note}
{warning}
If no handler is defined that can handle the received message (including the raw byte array), an error will
be logged and the message will be rejected.
{warning}

TODO: link to converters

The plugin has built-in converters for @Integer@, @Map@, @List@, and @String@ types. The plugin allows users
to define their own converters to convert other object types, which will be discussed later in this guide.

h3. MessageContext Object
The message context is just an object that encapsulates the data relevant to the received message.  Below
is a list of properties of the class.
{table}
*Property* | *Description*
@body@ | Incoming message in its raw @byte[]@ format.
@channel@ | The RabbitMQ channel the message handler should use to send messages. This is especially important when using transactions.
@consumerTag@ | Consumer tag
@envelope@ | Properties of the message's delivery (see RabbitMQ's [documentation|http://www.rabbitmq.com/releases/rabbitmq-java-client/v3.1.5/rabbitmq-java-client-javadoc-3.1.5/com/rabbitmq/client/Envelope.html])
@properties@ | Properties of the message (see RabbitMQ's [documentation|http://www.rabbitmq.com/releases/rabbitmq-java-client/v3.1.5/rabbitmq-java-client-javadoc-3.1.5/com/rabbitmq/client/BasicProperties.html])
{table}

h3. RPC-Style Messages
When a client sends a message and waits for a return reply, this is considered an RPC-style operation. Typically, the server-side of the operation (in this case, a message consumer/handler) must
respond to the client on a queue that the client requested manually. This plugin provides a very convenient method to respond to the client without having to manually construct a response message.

The client will provide a response queue to the server to reply to. This queue name is stored in the @MessageContext.properties.replyTo@ variable. If a client sends this variable, and the handler returns
some data, the plugin will convert the data returned from the message handler and build a response message for you.

{note}
Allowing the plugin to build a reply message only converts the data returned from the message handler and sends it to the reply queue. If you need to set any of the other message properties,
like headers, content-types, etc, you must manually build the response message, and refrain from returning data from the message handler.
{note}

